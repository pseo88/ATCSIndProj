# ATCSIndProj
This is my final project for the 2024 Advanced Topics in CS course at Polytechnic School

Initially, I wanted to explore a different type of sorting algorithm after my quick sort analysis. To figure out which sorting algorithm I wanted to further explore, I decided to pull up the video that Mr. White used to show us the different sorting algorithms in real time. While I couldn't really decide which sorting algorithm to use at first, I realized after watching bogo sort work, that was the sorting algorithm that I really wanted to do. However, Mr. White, upon finding out about my decision to analyze bogo sort, immediately shut down my idea as he said it wasn't advanced enough. Reflecting my sorrows, I intended to find a different form of algorithm to analyze. 

It took ages, but I finally exposed the finer details of a new algorithm I've never heard of before: greedy algorithms. The concept seemed simple enough, as greedy algorithms were algorithms made with the single mindset to take all the data in a particular problem/situation and to take the most efficient/fast solution at the current step. Therefore, the algorithm will continue to run until it completes its objective, going through the process choosing the most enticing option, hence the concept of "greed."

To begin exploring different situations that use greedy algorithms, I searched up online various scenarios. Among many, I ended up choosing the coin change function, the activity selection function, and the interval scheduling function. While the concept for each seemed particularly easy, I actually really struggled with coming up with code that worked for each function. However, after finally getting each of the following to work, I can explain the inner workings of each function:
-coin_change: In this scenario, I was tasked to generate a function that uses coins (pennies, nickels, dimes, and quarters) to equate to a certain value in the least total amount of coins possible. This one was the easiest to code out of the three, as all I had to do was create an empty array that would make a list of the coins used, and then if the amount was greater than the coin I'm testing for, then I knew I could subtract that coin's value until I have the least amount of coins that equate to the certain value I'm testing.
-activity_selection: In this scenario, I was tasked to generate a function that would select activities based on the difference between the start and finish time of an activity (basically how quickly an activity would go). While I thought this would be really easy to do, my original work was really messy, so I had to watch a video that would guide me and I was able to streamline my work.
-schedule: In this scenario, I was tasked to make a schedule based on the idea that no activities could conflict each other (essentially the start time of one activity couldn't be in the duration of another activity's start-to-finish time). Something about this that might be unique is that I chose that the start time cannot be the same value as an end time, as it would mean that these intervals do overlap and would not be compatible. Similar to the activity_selection program, my original code was really messy, but after some time, I made a much more simple version that works better.

That concludes my individual project. I think this was a good experience because I was able to gain further insight in a subject I wasn't familiar with. Additionally, I chose this for my project because the concept seemed simple, but actually employing it was more difficult than previously anticipated. However, I'm pretty proud of my work!